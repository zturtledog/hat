InitWindow[i32,, pointer];
//bool WindowShouldClose[];
CloseWindow[];
// bool IsWindowReady[];
// bool IsWindowFullscreen[];
// bool IsWindowHidden[];
// bool IsWindowMinimized[];
// bool IsWindowMaximized[];
// bool IsWindowFocused[];
// bool IsWindowResized[];
// bool IsWindowState[u32];
SetWindowState[u32];
ClearWindowState[u32];
ToggleFullscreen[];
MaximizeWindow[];
MinimizeWindow[];
RestoreWindow[];
// SetWindowIcon[Image];
SetWindowTitle[pointer];
SetWindowPosition[i32, i32];
SetWindowMonitor[i32];
SetWindowMinSize[i32, i32];
SetWindowSize[i32, i32];
pointer GetWindowHandle[];
i32 GetScreenWidth[];
i32 GetScreenHeight[];
i32 GetMonitorCount[];
i32 GetCurrentMonitor[];
// Vector2 GetMonitorPosition[i32];
i32 GetMonitorWidth[i32];
i32 GetMonitorHeight[i32];
i32 GetMonitorPhysicalWidth[i32];
i32 GetMonitorPhysicalHeight[i32];
i32 GetMonitorRefreshRate[i32];
// Vector2 GetWindowPosition[];
// Vector2 GetWindowScaleDPI[];
pointer GetMonitorName[i32];
SetClipboardText[pointer];
pointer GetClipboardText[];
ShowCursor[];
HideCursor[];
// bool IsCursorHidden[];
EnableCursor[];
DisableCursor[];
// bool IsCursorOnScreen[];
// ClearBackground[Color];
BeginDrawing[];
EndDrawing[];
// BeginMode2D[Camera2D];
EndMode2D[];
// BeginMode3D[Camera3D];
EndMode3D[];
// Begi32extureMode[RenderTexture2D];
EndTextureMode[];
// BeginShaderMode[Shader];
EndShaderMode[];
BeginBlendMode[i32];
EndBlendMode[];
BeginScissorMode[i32,, i32];
EndScissorMode[];
// BeginVrStereoMode[VrStereoConfig];
EndVrStereoMode[];
// VrStereoConfig LoadVrStereoConfig[VrDeviceInfo];
// UnloadVrStereoConfig[VrStereoConfig];
//, pointer];
//, pointer];
//, pointer];
i32, pointer];
//, i32];
//, i32];
//, Matrix];
//, Texture2D];
// UnloadShader[Shader];
//, Camera];
// Matrix GetCameraMatrix[Camera];
// Matrix GetCameraMatrix2D[Camera2D];
//, Camera];
//, i32];
//, Camera2D];
//, Camera2D];
// SetTargetFPS[i32];
i32 GetFPS[];
f32 GetFrameTime[];
f64 GetTime[];
i32, i32];
SetRandomSeed[u32];
TakeScreenshot[pointer];
SetConfigFlags[u32];
TraceLog[i32, pointer];
SetTraceLogLevel[i32];
pointer MemAlloc[i32];
pointer, i32];
MemFree[pointer];
// SetTraceLogCallback[TraceLogCallback];
// SetLoadFileDataCallback[LoadFileDataCallback];
// SetSaveFileDataCallback[SaveFileDataCallback];
// SetLoadFileTextCallback[LoadFileTextCallback];
// SetSaveFileTextCallback[SaveFileTextCallback];
pointer, u32];
UnloadFileData[pointer];
//, u32];
pointer LoadFileText[pointer];
UnloadFileText[pointer];
//, pointer];
// bool FileExists[pointer];
// bool DirectoryExists[pointer];
//, pointer];
pointer GetFileExtension[pointer];
pointer GetFileName[pointer];
pointer GetFileNameWithoutExt[pointer];
pointer GetDirectoryPath[pointer];
pointer GetPrevDirectoryPath[pointer];
pointer GetWorkingDirectory[];
//, pointer];
ClearDirectoryFiles[];
// bool ChangeDirectory[pointer];
// bool IsFileDropped[];
// **GetDroppedFiles[pointer];
ClearDroppedFiles[];
i64 GetFileModTime[pointer];
pointer, pointer];
pointer, pointer];
pointer, pointer];
pointer, pointer];
// bool SaveStorageValue[u32];
i32 LoadStorageValue[u32];
OpenURL[pointer];
// bool IsKeyPressed[i32];
// bool IsKeyDown[i32];
// bool IsKeyReleased[i32];
// bool IsKeyUp[i32];
SetExitKey[i32];
i32 GetKeyPressed[];
i32 GetCharPressed[];
// bool IsGamepadAvailable[i32];
pointer GetGamepadName[i32];
bool IsGamepadButtonPressed(int gamepad, int button);                   // Check if a gamepad button has been pressed once
bool IsGamepadButtonDown(int gamepad, int button);                      // Check if a gamepad button is being pressed
bool IsGamepadButtonReleased(int gamepad, int button);                  // Check if a gamepad button has been released once
bool IsGamepadButtonUp(int gamepad, int button);
i32 GetGamepadButtonPressed[];
i32 GetGamepadAxisCount[i32];
float GetGamepadAxisMovement(int gamepad, int axis);
i32 SetGamepadMappings[pointer];
// bool IsMouseButtonPressed[i32];
// bool IsMouseButtonDown[i32];
// bool IsMouseButtonReleased[i32];
// bool IsMouseButtonUp[i32];
i32 GetMouseX[];
i32 GetMouseY[];
// Vector2 GetMousePosition[];
// Vector2 GetMouseDelta[];
SetMousePosition[i32, i32];
SetMouseOffset[i32, i32];
SetMouseScale[f32, f32];
f32 GetMouseWheelMove[];
SetMouseCursor[i32];
i32 GetTouchX[];
i32 GetTouchY[];
// Vector2 GetTouchPosition[i32];
i32 GetTouchPointId[i32];
i32 GetTouchPoi32Count[];
SetGesturesEnabled[u32];
// bool IsGestureDetected[i32];
i32 GetGestureDetected[];
f32 GetGestureHoldDuration[];
// Vector2 GetGestureDragVector[];
f32 GetGestureDragAngle[];
// Vector2 GetGesturePinchVector[];
f32 GetGesturePinchAngle[];
//, i32];
UpdateCamera[pointer];
SetCameraPanControl[i32];
SetCameraAltControl[i32];
SetCameraSmoothZoomControl[i32];
SetCameraMoveControls[i32,, i32];
SetShapesTexture[Texture2D, Rectangle];
DrawPixel[i32, Color];
DrawPixelV[Vector2, Color];
DrawLine[i32, Color];
DrawLineV[Vector2, Color];
DrawLineEx[Vector2, Color];
DrawLineBezier[Vector2, Color];
DrawLineBezierQuad[Vector2, Color];
DrawLineBezierCubic[Vector2, Color];
DrawLineStrip[Vector2, Color];
DrawCircle[i32, Color];
DrawCircleSector[Vector2, Color];
DrawCircleSectorLines[Vector2, Color];
DrawCircleGradient[i32, Color 2];
DrawCircleV[Vector2, Color];
DrawCircleLines[i32, Color];
DrawEllipse[i32, Color];
DrawEllipseLines[i32, Color];
DrawRing[Vector2, Color];
DrawRingLines[Vector2, Color];
DrawRectangle[i32, Color];
DrawRectangleV[Vector2, Color];
DrawRectangleRec[Rectangle, Color];
DrawRectanglePro[Rectangle, Color];
DrawRectangleGradientV[i32, Color];
DrawRectangleGradientH[i32, Color];
DrawRectangleGradientEx[Rectangle, Color col4];
DrawRectangleLines[i32, Color];
DrawRectangleLinesEx[Rectangle, Color];
DrawRectangleRounded[Rectangle, Color];
DrawRectangleRoundedLines[Rectangle, Color];
DrawTriangle[Vector2, Color];
DrawTriangleLines[Vector2, Color];
DrawTriangleFan[Vector2, Color];
DrawTriangleStrip[Vector2, Color];
DrawPoly[Vector2, Color];
DrawPolyLines[Vector2, Color];
DrawPolyLinesEx[Vector2, Color];

// Basic shapes collision detection functions
bool, Rectangle rec2];
bool, f32 radius2];
bool, Rectangle rec];
bool, Rectangle rec];
bool, f32 radius];
bool, Vector2 p3];
bool, Vector2 *collisionPoi32];
bool, i32 threshold];
Rectangle, Rectangle rec2];





// Image loading functions
// NOTE: These functions do not require GPU access
Image LoadImage[pointer fileName];
Image, i32 headerSize];
Image, i32 *frames];
Image, i32 dataSize];
Image LoadImageFromTexture[Texture2D texture];
Image LoadImageFromScreen[];
UnloadImage[Image image];
bool, pointer fileName];
bool, pointer fileName];

// Image generation functions
Image, Color];
Image, Color bottom];
Image, Color right];
Image, Color outer];
Image, Color col2];
Image, f32 factor];
Image, i32 tileSize];

// Image manipulation functions
Image ImageCopy[Image image];
Image, Rectangle rec];
Image, Color];
Image, Color ti32];
ImageFormat[Image, i32 newFormat];
ImageToPOT[Image, Color fill];
ImageCrop[Image, Rectangle crop];
ImageAlphaCrop[Image, f32 threshold];
ImageAlphaClear[Image, f32 threshold];
ImageAlphaMask[Image, Image alphaMask];
ImageAlphaPremultiply[Image *image];
ImageResize[Image, i32 newHeight];
ImageResizeNN[Image,i32 newHeight];
ImageResizeCanvas[Image, Color fill];
ImageMipmaps[Image *image];
ImageDither[Image, i32 aBpp];
ImageFlipVertical[Image *image];
ImageFlipHorizontal[Image *image];
ImageRotateCW[Image *image];
ImageRotateCCW[Image *image];
ImageColorTint[Image, Color];
ImageColorInvert[Image *image];
ImageColorGrayscale[Image *image];
ImageColorContrast[Image, f32 contrast];
ImageColorBrightness[Image, i32 brightness];
ImageColorReplace[Image, Color replace];
Color *LoadImageColors[Image image];
Color, i32 *sCount];
UnloadImageColors[Color *s];
UnloadImagePalette[Color *s];
Rectangle, f32 threshold];
Color, i32 y];

// Image drawing functions
// NOTE: Image software-rendering functions [CPU]
ImageClearBackground[Image, Color];
ImageDrawPixel[Image, Color];
ImageDrawPixelV[Image, Color];
ImageDrawLine[Image, Color];
ImageDrawLineV[Image, Color];
ImageDrawCircle[Image, Color];
ImageDrawCircleV[Image, Color];
ImageDrawRectangle[Image, Color];
ImageDrawRectangleV[Image, Color];
ImageDrawRectangleRec[Image, Color];
ImageDrawRectangleLines[Image, Color];
ImageDraw[Image, Color ti32];
ImageDrawText[Image, Color];
ImageDrawTextEx[Image, Color ti32];

// Texture loading functions
// NOTE: These functions require GPU access
Texture2D LoadTexture[pointer fileName];
Texture2D LoadTextureFromImage[Image image];
TextureCubemap, i32 layout];
RenderTexture2D, i32 height];
UnloadTexture[Texture2D texture];
UnloadRenderTexture[RenderTexture2D target];
UpdateTexture[Texture2D, const void *pixels];
UpdateTextureRec[Texture2D, const void *pixels];

// Texture configuration functions
GenTextureMipmaps[Texture2D *texture];
SetTextureFilter[Texture2D, i32 filter];
SetTextureWrap[Texture2D, i32 wrap];

// Texture drawing functions
DrawTexture[Texture2D, Color ti32];
DrawTextureV[Texture2D, Color ti32];
DrawTextureEx[Texture2D, Color ti32];
DrawTextureRec[Texture2D, Color ti32];
DrawTextureQuad[Texture2D, Color ti32];
DrawTextureTiled[Texture2D, Color ti32];
DrawTexturePro[Texture2D, Color ti32];
DrawTextureNPatch[Texture2D, Color ti32];
DrawTexturePoly[Texture2D, Color ti32];

// Color/pixel related functions
Color, f32 alpha];
i32 ColorToint[Color];
Vector4 ColorNormalize[Color];
Color ColorFromNormalized[Vector4 normalized];
Vector3 ColorToHSV[Color];
Color, f32 value];
Color, f32 alpha];
Color, Color ti32];
Color GetColor[u32];
Color, i32 format];
SetPixelColor[void, i32 format];
i32, i32 format];




// Font loading/unloading functions
Font GetFontDefault[];
Font LoadFont[pointer fileName];
Font, i32 glyphCount];
Font, i32 firstChar];
Font, i32 glyphCount];
GlyphInfo, i32 type];
Image, i32 packMethod];
UnloadFontData[GlyphInfo, i32 glyphCount];
UnloadFont[Font font];

// Text drawing functions
DrawFPS[i32, i32 posY];
DrawText[pointer, Color];
DrawTextEx[Font, Color ti32];
DrawTextPro[Font, Color ti32];
DrawTextCodepoint[Font, Color ti32];

// Text misc. functions
i32, i32 fontSize];
Vector2, f32 spacing];
i32, i32 codepoi32];
GlyphInfo, i32 codepoi32];
Rectangle, i32 codepoi32];

// Text codepoi32s management functions [unicode characters]
i32, i32 *count];
UnloadCodepoints[i32 *codepoi32s];
i32 GetCodepointCount[pointer text];
i32, i32 *bytesProcessed];
pointer, i32 *byteSize];
char, i32 length];

//, only byte chars] 
//, just be careful! 
i32, pointer src];
bool, pointer text2];
u32];
pointer, ...];
pointer, i32 length];
char, pointer by];
char, i32 position];
pointer, pointer delimiter];
pointer, i32 *count];
TextAppend[char, i32 *position];
i32, pointer find];
pointer TextToUpper[pointer text];
pointer TextToLower[pointer text];
pointer TextToPascal[pointer text];
i32 TextToi32eger[pointer text];




// Basic geometric 3D shapes drawing functions
DrawLine3D[Vector3, Color];
DrawPoi323D[Vector3, Color];
DrawCircle3D[Vector3, Color];
DrawTriangle3D[Vector3, Color];
DrawTriangleStrip3D[Vector3, Color];
DrawCube[Vector3, Color];
DrawCubeV[Vector3, Color];
DrawCubeWires[Vector3, Color];
DrawCubeWiresV[Vector3, Color];
DrawCubeTexture[Texture2D, Color];
DrawCubeTextureRec[Texture2D, Color];
DrawSphere[Vector3, Color];
DrawSphereEx[Vector3, Color];
DrawSphereWires[Vector3, Color];
DrawCylinder[Vector3, Color];
DrawCylinderEx[Vector3, Color];
DrawCylinderWires[Vector3, Color];
DrawCylinderWiresEx[Vector3, Color];
DrawPlane[Vector3, Color];
DrawRay[Ray, Color];
DrawGrid[i32, f32 spacing];

// Model loading/unloading functions
Model LoadModel[pointer fileName];
Model LoadModelFromMesh[Mesh mesh];
UnloadModel[Model model];
UnloadModelKeepMeshes[Model model];
BoundingBox GetModelBoundingBox[Model model];

// Model drawing functions
DrawModel[Model, Color ti32];
DrawModelEx[Model, Color ti32];
DrawModelWires[Model, Color ti32];
DrawModelWiresEx[Model, Color ti32];
DrawBoundingBox[BoundingBox, Color];
DrawBillboard[Camera, Color ti32];
DrawBillboardRec[Camera, Color ti32];
DrawBillboardPro[Camera, Color ti32];

// Mesh management functions
UploadMesh[Mesh, bool dynamic];
UpdateMeshBuffer[Mesh, i32 offset];
UnloadMesh[Mesh mesh];
DrawMesh[Mesh, Matrix transform];
DrawMeshInstanced[Mesh, i32 instances];
bool, pointer fileName];
BoundingBox GetMeshBoundingBox[Mesh mesh];
GenMeshTangents[Mesh *mesh];
GenMeshBinormals[Mesh *mesh];

// Mesh generation functions
Mesh, f32 radius];
Mesh, i32 resZ];
Mesh, f32 length];
Mesh, i32 slices];
Mesh, i32 slices];
Mesh, i32 slices];
Mesh, i32 slices];
Mesh, i32 sides];
Mesh, i32 sides];
Mesh, Vector3 size];
Mesh, Vector3 cubeSize];

// Material loading/unloading functions
Material, i32 *materialCount];
Material LoadMaterialDefault[];
UnloadMaterial[Material material];
SetMaterialTexture[Material, Texture2D texture];
SetModelMeshMaterial[Model, i32 materialId];

// Model animations loading/unloading functions
ModelAnimation, u32];
UpdateModelAnimation[Model, i32 frame];
UnloadModelAnimation[ModelAnimation anim];
UnloadModelAnimations[ModelAnimation*, u32];
bool, ModelAnimation anim];

// Collision detection functions
bool, f32 radius2];
bool, BoundingBox box2];
bool, f32 radius];
RayCollision, f32 radius];
RayCollision, BoundingBox box];
RayCollision, Model model];
RayCollision, Matrix transform];
RayCollision, Vector3 p3];
RayCollision, Vector3 p4];



InitAudioDevice[];
CloseAudioDevice[];
bool IsAudioDeviceReady[];
SetMasterVolume[f32 volume];

// Wave/Sound loading/unloading functions
Wave LoadWave[pointer fileName];
Wave, i32 dataSize];
Sound LoadSound[pointer fileName];
Sound LoadSoundFromWave[Wave wave];
UpdateSound[Sound, i32 samplesCount];
UnloadWave[Wave wave];
UnloadSound[Sound sound];
bool, pointer fileName];
bool, pointer fileName];

// Wave/Sound management functions
PlaySound[Sound sound];
StopSound[Sound sound];
PauseSound[Sound sound];
ResumeSound[Sound sound];
PlaySoundMulti[Sound sound];
StopSoundMulti[];
i32 GetSoundsPlaying[];
bool IsSoundPlaying[Sound sound];
SetSoundVolume[Sound, f32 volume];
SetSoundPitch[Sound, f32 pitch];
WaveFormat[Wave, i32 channels];
Wave WaveCopy[Wave wave];
WaveCrop[Wave, i32 finalSample];
f32 *LoadWaveSamples[Wave wave];
UnloadWaveSamples[f32 *samples];

// Music management functions
Music LoadMusicStream[pointer fileName];
Music, i32 dataSize];
UnloadMusicStream[Music music];
PlayMusicStream[Music music];
bool IsMusicStreamPlaying[Music music];
UpdateMusicStream[Music music];
StopMusicStream[Music music];
PauseMusicStream[Music music];
ResumeMusicStream[Music music];
SeekMusicStream[Music, f32 position];
SetMusicVolume[Music, f32 volume];
SetMusicPitch[Music, f32 pitch];
f32 GetMusicTimeLength[Music music];
f32 GetMusicTimePlayed[Music music];

// AudioStream management functions
AudioStream LoadAudioStream[u32];
UpdateAudioStream[AudioStream, i32 samplesCount];
CloseAudioStream[AudioStream stream];
bool IsAudioStreamProcessed[AudioStream stream];
PlayAudioStream[AudioStream stream];
PauseAudioStream[AudioStream stream];
ResumeAudioStream[AudioStream stream];
bool IsAudioStreamPlaying[AudioStream stream];
StopAudioStream[AudioStream stream];
SetAudioStreamVolume[AudioStream, f32 volume];
SetAudioStreamPitch[AudioStream, f32 pitch];
SetAudioStreamBufferSizeDefault[i32 size];




